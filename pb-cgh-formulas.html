<!DOCTYPE html>
<html>
<head>
	<title>PH CGH formulas | Learning Holography</title>
	<link href="css/base-style.css" rel="stylesheet">
	<meta charset="utf-8">
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
		tex2jax: { inlineMath: [['$','$'],['\\(','\\)']] },
		TeX: { equationNumbers: { autoNumber: "AMS" } }
	  });
	</script>
    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!--    <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>-->
  </head>
  <body>

<a href="index.html">&larr; back</a>

<h2>Step-by-step derivation of the physically-based computer-generated hologram formula</h2>

<p class="note"><b>Note:</b> This guide assumes the reader already knows
<a href="http://en.wikipedia.org/wiki/Holography">what a hologram is</a>
and, in broad terms, the basic principles of how to make one.</p>

<p>So, we have a 3D object which we want a hologram of.
To do that, we first decompose the object into a large number of points,
which we approximate as spherical light sources
(for now we ignore the opacity of the object,
which would make the front points to block the light from the back ones
from reaching the holographic plate).</p>
<img src="img/stanford-bunny.png" width="240px" style="vertical-align:middle;">
<b style="font-size:x-large">➔</b>
<img src="img/stanford-bunny-points.png" width="220px" style="vertical-align:middle;">

<p>To make the hologram, we also need a reference wave,
which will act as the "key" to decode the interference pattern that we will generate.
The reference wave is a plane wave, i.e. it can be thought of
as a series of parallel planes spread apart by the wavelength $\lambda$,
each corresponding to a crest in the wave.</p>
<p style="text-align:center"><img src="img/plane-wave.svg" width="400"></p>

<p>Our system of coordinates will be the
<a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system#Orientation_and_handedness">left-handed cartesian</a>,
with X pointing to the right, Y pointing up, and Z pointing forward (from the object to the hologram).
The hologram will be a plane centered at the origin of the system of coordinates,
and perpendicular to the Z axis (i.e., it will be the XY plane).</p>
</p>
Given the above, we'll define the following elements for our calculations:
<ul>
	<li>$h = (h_x, h_y, 0)$, a point on the hologram plane ($z = 0$),</li>
	<li>$p_n = (p_{nx}, p_{ny}, p_{nz})$, the location of the $n^{th}$ object point light source</li>
</ul>

<p style="text-align:center"><img src="img/scene.svg" width="500"></p>

To start, we know that the value of a single wave at the origin of the coordinate system at instant $t$ is

\[
A \times \cos(\omega t - \varphi)
\]

<p>...where $A$ is the amplitude (maximum height) of the wave,
$\omega$ is the temporal angular frequency of the wave
(i.e. how many cycles, in radians, the wave completes per unit of time)
and $\varphi$ is the initial phase (angle) of the wave at the origin.
So both $\omega t$ and $\varphi$ are angles, which are subtracted to yield
the real phase angle of the wave at instant $t$.</p>

<p>Using this formulation, the amplitude of the whole compound object wave,
made up of all $N$ object points,
at a given point $h$ of the hologram and a given time $t$,
is given by simply summing all contributions together:</p>

\[
obj(h,t)=\sum_n^N A_n \cos(\omega t - \varphi_n)
\]

Here, $\varphi_n$ is the initial phase (at $t=0$)
of the spherical wave emitted from point $n$
at hologram point $h$.
It depends on the distance from the object point
to the hologram point being considered, which is calculated
using the familiar <a href="http://en.wikipedia.org/wiki/Euclidean_distance">
Euclidean distance</a> formula:

\[
r_n(h) = \sqrt{(p_{nx} - h_x)^2 + (p_{ny} - h_y)^2 + p_{nz}^2}
\]

<p>(remember that $h_z$ is zero, because we placed the hologram plane at $z=0$).</p>

<p>This distance (called "r" to underline its meaning as the <em>radius</em>
of the light sphere emitted from the $n^{th}$ point)
is then multiplied by the angular spatial frequency of the wave
(i.e. how many cycles, in radians, the wave completes per unit of distance),
which is abbreviated as $k = \tau/\lambda$, and —somewhat unhelpfully—
called the "wavenumber". This multiplication, $k \times r_n(h)$,
like the $\omega \times t$ one, yields a phase angle, so both values can be
subtracted to yield the phase of the wave $p_n$ at point $h$ and instant $t$.</p>

<p>Note that here we're considering that the wave is leagving the object point
at phase zero, which is not true: because the object is not self-luminous,
but rather is reflecting the reference wave towards the hologram,
the initial phase at the object point will depend on its position
along the direction of propagation of the wave,
so the initial phase at the hologram point naturally depends on this as well.
Ideally we would subtract it, as in $k r_n(h) - \varphi_{n0}$.
However,
<span class="todo">(TODO: copy from google docs)</span>
</p>

The formula above then becomes:

\begin{equation}
	obj(h,t)=\sum_n^N A_n \cos(\omega t - k r_n(h))
	\label{eq:obj}
\end{equation}

Note how the duality of this generic formula can be exploited
to calculate both the variation of the object wavefront in space
(i.e. across the hologram), at a given instant frozen in time,
by varying $h$ and keeping $t$ constant,
and to calculate the variation of the object wavefront at a fixed
hologram point, by varying $t$ and keeping $h$ constant.

<h3>Adding the reference wave</h3>
<!-- Note: the R subscript for the reference wave
  -- is done using a small capital R, i.e. ʀ (U+0280),
  -- which plays better visually with the lowercase subscript of the object wave(s).
  -- Inserting the character directly in the source in HTML+MathJax works,
  -- but in pure latex, this would likely be done through the IPA package \usepackage{tipa}
  -- and the command \textscr. Not sure if it works in math mode, though.
  -->

<p>As may be noted, the above formula is just for the compound object wave.
We still need to add the reference wave
to get the complete wavefront that will form the hologram.</p>

<p>As we mentioned above, the reference wave is a planar wave
(<span class="todo">TODO: explain why</span>),
so it's formula can't be defined as based on the distance of its center,
like for the spherical point waves, because by definition, a planar wave
is a wave whose focal point is at an infinite distance, so the curvature
of its wavefronts is zero. What we do, instead, is define it
by the angles it makes with the hologram plane.</p>

<p>This is done using two angles: $\theta_y$, aka "yaw", which represents its rotation
around the (vertical) Y axis (like a head turning side to side),
and $\theta_x$, aka "pitch", which represents its rotation
around the (horizontal) X axis (like a head nodding up and down).<p>

<p>Let's start by considering $\theta_x=0$ and seeing what happens as we change $\theta_y$:</p>

<p style="text-align:center"><img src="img/plane-wave-projection.svg" width="400"></p>

<p>This image shows a top-down view of the scene,
assuming the reference wave only changes in "yaw",
so subsequent wavefronts, although planar, would be seen as parallel lines from the top.
As you can see, if we adjust the angle $\theta_y$,
although the wavelength $\lambda$ would remain the same,
the distance between two wave crests in the hologram plane would change.
In other words, it's the projection of $\lambda$ into the X axis.
We'll call this $\lambda_x$.</p>

<p>Using elementary trigonometry, we can see that,
using the definition of the sine of an angle
as <a href="http://en.wikipedia.org/wiki/Sohcahtoa#Mnemonics">opposite/hypotenuse</a>,
we obtain the relationship $\sin(\theta_y) = \lambda/\lambda_x$,
and therefore, $\lambda_x = \lambda/\sin(\theta_y)$.</p>

<p>Now, having the wavelength of the reference wave along the hologram plane,
we can, for every location $h_x$, obtain the value of the wave (i.e. its phase).
For example, assuming the wave's phase at $h_x=0$ is zero,
the wave will have completed a full cycle (thus the phase will be zero again)
at $h_x=\lambda_x$. So, to get the reference wave phase at any given $h_x$,
we just divide it by $\lambda_x$.</p>

<p>Of course, this gives us a fractional value,
a linearly growing value representing the number of cycles completed as we advance $h_x$.
To pass this value to the cosine function
and thus get the amplitude of the wave, we need to convert this to radians,
which we do by multiplying the fractional value by $\tau$.
The formula for a (yaw-only) reference wave is thus:</p>

\[
A_ʀ \cos ( \omega t - \frac{h_x}{\lambda_x} \tau )
\]

<p>The same reasoning can be made for the case where we vary $\theta_x$
and keep $\theta_y=0$ — we obtain $\lambda_y = \lambda / \sin(\theta_x)$.
So putting it all together, for the general case where both $\theta_x \neq 0$ and $\theta_y \neq 0$:</p>

\[
A_ʀ \cos \left[ \omega t - \left( \frac{h_x}{\lambda/\sin(\theta_y)} \tau + \frac{h_y}{\lambda/\sin(\theta_x)} \tau \right) \right]
\]

By rearranging the pieces, and because $k=\tau/\lambda$, this becomes:

\[
A_ʀ \cos \left[ \omega t - k \left( h_x \sin(\theta_y) + h_y \sin(\theta_x) \right) \right]
\]

To make this similar to the object wave function,
we can abstract away the inner sum that's multiplied by $k$
into a function $p$ (named that way to stress its meaning
as the <em>projection</em> of the reference wave into the hologram plane):

\[
p_ʀ(h) = \left( h_x \sin(\theta_y) + h_y \sin(\theta_x) \right)
\]

thus yielding the reference wave formula:

\begin{equation}
	ref(h,t)=A_ʀ \cos ( \omega t - k p_ʀ(h) )
	\label{eq:ref}
\end{equation}

<h3>Putting the pieces together</h3>

Ok, now that we have the object and the reference wave described as simple formulas,
we can compute the hologram.
To do that, we simply go over each point $h$ in the hologram,
and sum the object and the reference waves,
obtaining the interference field $E$:

\[
E(h) = obj(h) + ref(h)
\]

which, when combined with \eqref{eq:obj} and \eqref{eq:ref}, expands to:

\begin{equation}
	E(h) = \sum_n^N A_n \cos(\omega t - k r_n(h)) + A_ʀ \cos ( \omega t - k p_ʀ(h) )
	\label{eq:interference}
\end{equation}

<p>However, this only gives us the instantaneous interference pattern
created from the interaction of all these waves at a given moment $t$.
The actual hologram is the result of the static "nodes" created when coherent waves interact.
These nodes will have zero activity, while other points in the hologram will register oscillations.</p>

<p>Now, although these oscillations have all the same period, because the waves are coherent,
their peaks and valleys will occurr at different stages of the "global" cycle.
And each of these oscillation zones will have the value zero at the right time in their cycle.
So that makes it <b>impossible, in an instant snapshot, to distinguish permanently static zones
from zones that only happen to be passing through zero at that moment</b>.</p>

<p>To solve this, we have to calculate the interference pattern
for all possible phase positions of the global cycle and accumulate any activity,
to make the oscillation zones unambiguously distinguishable from the true, static nodes
of the interference pattern.</p>

<p>The straightforward way to do that is to discretize the phase space
into a finite set of regularly-spaced phase values,
calculate the interference pattern at each phase value, and sum them all
to yield the hologram.</p>

<p>Note that, precisely because each oscillation in the pattern
occurs over the same length of time, and because the oscillations
consist in the wave cycling between positive and negative values,
simply summing the interference pattern over a wave cycle
would result in zero everywhere. We need to make sure the values we're summing
actually accumulate, rather than cancel out.<p>

<p>Fortunately, what the holographic plate registers is <b>intensity, not amplitude</b>,
and intensity is proportional to the amplitude squared.
The squaring, conveniently, provides us with only positive values,
which can indeed be summed and accumulated properly.</p>

The cumulative interference pattern (i.e., the actual hologram) is thus obtained by:

\begin{equation}
holo(h) = \sum_t^T \left[ \sum_n^N A_n \cos(\omega t - k r_n(h)) + A_ʀ \cos ( \omega t - k p_ʀ(h)) \right]^2
	\label{eq:hologram}
\end{equation}

<p>This is all we need to make the hologram! Since we're talking about
computer-generated holograms, it is appropriate to present
the above equation in the form of a computer algorithm.
So, in pseudo-code, the equation above translates to:</p>

<pre>
var phaseSteps = 100
var holoPixels = 500
var objectPoints = [
    {x: ..., y: ..., z: ...},
    {x: ..., y: ..., z: ...},
    {x: ..., y: ..., z: ...} ]
var amplitude[], intensity[], hologram[]

for i = 0 --> phaseSteps {
  phase = i/phaseSteps * 2*pi
  for h = 0 --> holoPixels {
    amplitude[ h ] += ref-amplitude( h, phase )
    for each point in objectPoints {
      amplitude[ h ] += obj-amplitude( h, phase, p )
    }
    intensity[ h ] = amplitude[ h ]^2
  }
  hologram[] += intensity[]
}

# Normalize
hologram[] /= max( hologram[] )

# Auxiliary functions
ref-amplitude( h, phase ) {
  ...
}
obj-amplitude( h, phase, p ) {
  ...
}
</pre>

<p>But this is a rather naive approach,
which not only introduces a loss of precision in the quantization of both the object
and the phase space, but also requires a calculation over a given length of time
— in other words, it essentially implements an exposure period.</p>

In the next chapter, we will explore ways to make this calculation both more exact
and faster. <b><a href="pb-cgh-formulas-2.html">Onward!</a></b>

  </body>
</html>
