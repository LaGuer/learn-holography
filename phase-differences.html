<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Interactive two-point interference</title>
	<style>
	canvas { border: 1px dashed rgba(255,0,0,0.3); display: block; }
	#angle { width: 500px; }
	</style>
</head>
<body onload="refresh()">
	<p><b>Goal:</b> investigate the effect of point sources emitting same-wavelength light
	at different phases.</p>
	<p><label for="angle">Angle of the incident light:</label><span id="angleTxt"></span></p>
	<p><input type="range" name="angle" id="angle" value="20.6" min="-90" max="90" step="0.1" onchange="refresh()"></p>
	<canvas width="500" height="500" id="draw">
	<script type="text/javascript">
	var cnv = document.getElementById("draw"),
	    ctx = cnv.getContext('2d'),
	    w = cnv.width,
	    h = cnv.height,
		tau = Math.PI*2,
		deg2rad = tau/360,
		wavLen = h/10,
		cnvRad = distanceToOrigin(cnv.width, cnv.height) / 2,
		angle = document.getElementById("angle").value;

	ctx.translate(w/2, h/2); // make coordinate origin be at the center of the canvas
	ctx.scale(1,-1); // make the y axis grow upwards

	function refresh(){
		ctx.clearRect( -w/2, -h/2, w, h );
		angle = document.getElementById("angle").value;
		drawPlanarWave();
		drawCircularWaves();
		// Update the text with the current angle value
		document.getElementById("angleTxt").textContent = ' ' + angle + 'º';
	}

	function drawPlanarWave() {

		ctx.save();
		
		ctx.strokeStyle = "Silver";
		// the angle is inverted to make it more intuitive to manipulate
		ctx.rotate(-angle*deg2rad);

		ctx.beginPath();

		// Draw a set of horizontal lines (which, in a rotated coordinate system,
		// end up becoming rotated parallel lines)
		for (i=0; i<cnvRad; i+=wavLen) {
			ctx.moveTo(-cnvRad, i); ctx.lineTo( cnvRad, i);
			if (i == 0) { continue; } // don't draw the central line twice
			ctx.moveTo(-cnvRad,-i); ctx.lineTo( cnvRad,-i);
		}

		// Draw arrow showing the direction of propagation
		ctx.moveTo( 0, 0); //start at the origin
		ctx.lineTo( 0, wavLen*1.5);
		ctx.lineTo(-3, wavLen*1.5 - 7);
		ctx.moveTo( 0, wavLen*1.5);
		ctx.lineTo( 3, wavLen*1.5 - 7);

		ctx.stroke();

		ctx.restore();
	}

	function drawCircularWaves() {
		var points = [
			{ x:-w/3, y: 0 },
			{ x: w/3, y: -h/4 }
		];

		for (var pt = 0; pt < points.length; pt++) {
			var x = points[pt].x,
				y = points[pt].y;
			// Assuming phase of incoming planar wave (incident light) is zero at (0,0),
			// calculate the distance of each point to (0,0), along the propagation direction
			// since the propagation direction is "up" (in the rotated reference frame of the planar wave),
			// we can rotate the points by the same angle in the reverse direction.
			// The new y coordinate of the rotated point is the distance
			// along the rotaded Y axis of the plane wave reference system.
			// For this, we use the rotation formula y' = x*sin(θ) + y*cos(θ).
			// Note that the angle isn't inverted because the other transformation
			// already uses the inverted angle.
			var dist = x*Math.sin(angle*deg2rad) + y*Math.cos(angle*deg2rad);
			// Now get the phase. Normally this would be simply dist % wavLen,
			// but the % operator essentially "caps" the dist / wavLen line
			// (which is the pure 45º line of dist scaled down by 1/wavLen)
			// to the -wavLen --> wavLen range. This means the left side of the graph
			// is below the x axis, capped at -wavLen, and the right side is above,
			// capped at wavLen. We want to do the following:
			/*
				           ^                               ^
				           |                               |
				           | /| /| /|               /| /| /| /| /| /|
				___________|/_|/_|/_|_   ---->    _/_|/_|/_|/_|/_|/_|_
				 /| /| /| /|                               |
				/ |/ |/ |/ |                               |
				           |                               |
			*/
			// to achieve that, we first add wavLen to make the wole curve above 0,
			// and then we use % again to cap the wavLen --> 2*wavLen part that
			// results in the right-hand side.
			// Finally, we subtract that from wavLen, to get the growing with the
			// planar waves' propagation direction (+Y')
			var phase = wavLen - ( wavLen + dist % wavLen ) % wavLen;

			// Draw the point itself
			ctx.beginPath();
	    	ctx.arc(x, y, 5, 0, tau, false);
    		ctx.fill();

			// Draw the circular waves emanating from it
			for (rad=0; rad<cnvRad*2; rad+=wavLen) {
				ctx.beginPath();
		    	ctx.arc(x, y, rad+phase, 0, tau, false);
	    		ctx.stroke();
			}
		}
	}

	function distanceToOrigin(x, y) {
		return Math.sqrt( Math.pow(x,2) + Math.pow(y,2) );
	}
	</script>
</body>
</html>
